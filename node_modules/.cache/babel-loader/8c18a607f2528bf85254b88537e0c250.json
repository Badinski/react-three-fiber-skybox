{"ast":null,"code":"var _this = this,\n    _jsxFileName = \"C:\\\\Users\\\\Mihai\\\\Desktop\\\\egioc-project\\\\src\\\\App.js\";\n\nimport React, { useRef } from \"react\";\nimport { Canvas, extend, useThree, useFrame } from \"react-three-fiber\";\nimport { CubeTextureLoader, CubeCamera, WebGLCubeRenderTarget, RGBFormat, LinearMipmapLinearFilter } from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport \"./styles.css\";\nextend({\n  OrbitControls: OrbitControls\n});\n\nvar CameraControls = function CameraControls() {\n  // Get a reference to the Three.js Camera, and the canvas html element.\n  // We need these to setup the OrbitControls class.\n  // https://threejs.org/docs/#examples/en/controls/OrbitControls\n  var _useThree = useThree(),\n      camera = _useThree.camera,\n      domElement = _useThree.gl.domElement; // Ref to the controls, so that we can update them on every frame using useFrame\n\n\n  var controls = useRef();\n  useFrame(function () {\n    return controls.current.update();\n  });\n  return /*#__PURE__*/React.createElement(\"orbitControls\", {\n    ref: controls,\n    args: [camera, domElement],\n    autoRotate: false,\n    enableZoom: false,\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 29,\n      columnNumber: 5\n    }\n  });\n}; // Loads the skybox texture and applies it to the scene.\n\n\nfunction SkyBox() {\n  var _useThree2 = useThree(),\n      scene = _useThree2.scene;\n\n  var loader = new CubeTextureLoader(); // The CubeTextureLoader load method takes an array of urls representing all 6 sides of the cube.\n\n  var texture = loader.load([\"/1.jpg\", \"/2.jpg\", \"/3.jpg\", \"/4.jpg\", \"/5.jpg\", \"/6.jpg\"]); // Set the scene background property to the resulting texture.\n\n  scene.background = texture;\n  return null;\n} // Geometry\n\n\nfunction Sphere() {\n  var _useThree3 = useThree(),\n      scene = _useThree3.scene,\n      gl = _useThree3.gl; // The cubeRenderTarget is used to generate a texture for the reflective sphere.\n  // It must be updated on each frame in order to track camera movement and other changes.\n\n\n  var cubeRenderTarget = new WebGLCubeRenderTarget(256, {\n    format: RGBFormat,\n    generateMipmaps: true,\n    minFilter: LinearMipmapLinearFilter\n  });\n  var cubeCamera = new CubeCamera(1, 1000, cubeRenderTarget);\n  cubeCamera.position.set(0, 0, 0);\n  scene.add(cubeCamera); // Update the cubeCamera with current renderer and scene.\n\n  useFrame(function () {\n    return cubeCamera.update(gl, scene);\n  });\n  return /*#__PURE__*/React.createElement(\"mesh\", {\n    visible: true,\n    position: [0, 0, 0],\n    rotation: [0, 0, 0],\n    castShadow: true,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 75,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"directionalLight\", {\n    intensity: 0.5,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 76,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(\"sphereGeometry\", {\n    attach: \"geometry\",\n    args: [2, 32, 32],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 77,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    attach: \"material\",\n    envMap: cubeCamera.renderTarget.texture,\n    color: \"white\",\n    roughness: 0.1,\n    metalness: 1,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 78,\n      columnNumber: 7\n    }\n  }));\n} // Lights\n\n\nfunction App() {\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Canvas, {\n    className: \"canvas\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 93,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(CameraControls, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 94,\n      columnNumber: 9\n    }\n  }), /*#__PURE__*/React.createElement(Sphere, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 95,\n      columnNumber: 9\n    }\n  }), /*#__PURE__*/React.createElement(SkyBox, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 96,\n      columnNumber: 9\n    }\n  })), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"startup\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 99,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 100,\n      columnNumber: 9\n    }\n  }, \"* Use mouse to rotate the camera\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 101,\n      columnNumber: 9\n    }\n  }, \"* Use arrows to move camera axis around\")));\n}\n\nexport default App;","map":{"version":3,"sources":["C:/Users/Mihai/Desktop/egioc-project/src/App.js"],"names":["React","useRef","Canvas","extend","useThree","useFrame","CubeTextureLoader","CubeCamera","WebGLCubeRenderTarget","RGBFormat","LinearMipmapLinearFilter","OrbitControls","CameraControls","camera","domElement","gl","controls","current","update","SkyBox","scene","loader","texture","load","background","Sphere","cubeRenderTarget","format","generateMipmaps","minFilter","cubeCamera","position","set","add","renderTarget","App"],"mappings":"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","sourcesContent":["import React, { useRef } from \"react\";\nimport { Canvas, extend, useThree, useFrame } from \"react-three-fiber\";\nimport {\n  CubeTextureLoader,\n  CubeCamera,\n  WebGLCubeRenderTarget,\n  RGBFormat,\n  LinearMipmapLinearFilter\n} from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport \"./styles.css\";\n\nextend({ OrbitControls });\n\nconst CameraControls = () => {\n  // Get a reference to the Three.js Camera, and the canvas html element.\n  // We need these to setup the OrbitControls class.\n  // https://threejs.org/docs/#examples/en/controls/OrbitControls\n\n  const {\n    camera,\n    gl: { domElement }\n  } = useThree();\n\n  // Ref to the controls, so that we can update them on every frame using useFrame\n  const controls = useRef();\n  useFrame(() => controls.current.update());\n  return (\n    <orbitControls\n      ref={controls}\n      args={[camera, domElement]}\n      autoRotate={false}\n      enableZoom={false}\n    />\n  );\n};\n\n// Loads the skybox texture and applies it to the scene.\nfunction SkyBox() {\n  const { scene } = useThree();\n  const loader = new CubeTextureLoader();\n  // The CubeTextureLoader load method takes an array of urls representing all 6 sides of the cube.\n  const texture = loader.load([\n    \"/1.jpg\",\n    \"/2.jpg\",\n    \"/3.jpg\",\n    \"/4.jpg\",\n    \"/5.jpg\",\n    \"/6.jpg\"\n  ]);\n\n  // Set the scene background property to the resulting texture.\n  scene.background = texture;\n  return null;\n}\n\n// Geometry\nfunction Sphere() {\n  const { scene, gl } = useThree();\n  // The cubeRenderTarget is used to generate a texture for the reflective sphere.\n  // It must be updated on each frame in order to track camera movement and other changes.\n  const cubeRenderTarget = new WebGLCubeRenderTarget(256, {\n    format: RGBFormat,\n    generateMipmaps: true,\n    minFilter: LinearMipmapLinearFilter\n  });\n  const cubeCamera = new CubeCamera(1, 1000, cubeRenderTarget);\n  cubeCamera.position.set(0, 0, 0);\n  scene.add(cubeCamera);\n\n  // Update the cubeCamera with current renderer and scene.\n  useFrame(() => cubeCamera.update(gl, scene));\n\n  return (\n    <mesh visible position={[0, 0, 0]} rotation={[0, 0, 0]} castShadow>\n      <directionalLight intensity={0.5} />\n      <sphereGeometry attach=\"geometry\" args={[2, 32, 32]} />\n      <meshBasicMaterial\n        attach=\"material\"\n        envMap={cubeCamera.renderTarget.texture}\n        color=\"white\"\n        roughness={0.1}\n        metalness={1}\n      />\n    </mesh>\n  );\n}\n\n// Lights\nfunction App() {\n  return (\n    <>\n      <Canvas className=\"canvas\">\n        <CameraControls />\n        <Sphere />\n        <SkyBox />\n      </Canvas>\n\n      <div className=\"startup\">\n        <p>* Use mouse to rotate the camera</p>\n        <p>* Use arrows to move camera axis around</p>\n      </div>\n    </>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}