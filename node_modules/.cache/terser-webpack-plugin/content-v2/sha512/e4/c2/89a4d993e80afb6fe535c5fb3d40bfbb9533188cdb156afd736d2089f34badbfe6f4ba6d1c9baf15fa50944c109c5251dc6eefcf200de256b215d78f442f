{"map":"{\"version\":3,\"sources\":[\"C:/Users/Mihai/Desktop/egioc-project/src/App.js\",\"C:/Users/Mihai/Desktop/egioc-project/src/index.js\"],\"names\":[\"extend\",\"OrbitControls\",\"CameraControls\",\"_useThree\",\"useThree\",\"camera\",\"domElement\",\"gl\",\"controls\",\"useRef\",\"useFrame\",\"current\",\"update\",\"react_default\",\"a\",\"createElement\",\"ref\",\"args\",\"autoRotate\",\"enableZoom\",\"SkyBox\",\"scene\",\"texture\",\"CubeTextureLoader\",\"load\",\"background\",\"Sphere\",\"_useThree3\",\"cubeRenderTarget\",\"WebGLCubeRenderTarget\",\"format\",\"RGBFormat\",\"generateMipmaps\",\"minFilter\",\"LinearMipmapLinearFilter\",\"cubeCamera\",\"CubeCamera\",\"position\",\"set\",\"add\",\"visible\",\"rotation\",\"castShadow\",\"intensity\",\"attach\",\"envMap\",\"renderTarget\",\"color\",\"roughness\",\"metalness\",\"App\",\"Fragment\",\"web\",\"className\",\"App_CameraControls\",\"rootElement\",\"document\",\"getElementById\",\"ReactDOM\",\"render\",\"StrictMode\",\"src_App\"],\"mappings\":\"0NAYAA,OAAAA,EAAAA,EAAAA,CAAO,CAAEC,cAAAA,EAAAA,IAET,IAAMC,EAAiB,WAKrB,IAAAC,EAGIC,OAAAA,EAAAA,EAAAA,GAFFC,EADFF,EACEE,OACMC,EAFRH,EAEEI,GAAMD,WAIFE,EAAWC,OAAAA,EAAAA,OAAAA,GAEjB,OADAC,OAAAA,EAAAA,EAAAA,CAAS,WAAA,OAAMF,EAASG,QAAQC,WAE9BC,EAAAC,EAAAC,cAAA,gBAAA,CACEC,IAAKR,EACLS,KAAM,CAACZ,EAAQC,GACfY,YAAY,EACZC,YAAY,KAMlB,SAASC,IACP,IAAQC,EAAUjB,OAAAA,EAAAA,EAAAA,GAAViB,MAGFC,GAFS,IAAIC,EAAAA,mBAEIC,KAAK,CAC1B,SACA,SACA,SACA,SACA,SACA,WAKF,OADAH,EAAMI,WAAaH,EACZ,KAIT,SAASI,IACP,IAAAC,EAAsBvB,OAAAA,EAAAA,EAAAA,GAAdiB,EAARM,EAAQN,MAAOd,EAAfoB,EAAepB,GAGTqB,EAAmB,IAAIC,EAAAA,sBAAsB,IAAK,CACtDC,OAAQC,EAAAA,UACRC,iBAAiB,EACjBC,UAAWC,EAAAA,2BAEPC,EAAa,IAAIC,EAAAA,WAAW,EAAG,IAAMR,GAO3C,OANAO,EAAWE,SAASC,IAAI,EAAG,EAAG,GAC9BjB,EAAMkB,IAAIJ,GAGVzB,OAAAA,EAAAA,EAAAA,CAAS,WAAA,OAAMyB,EAAWvB,OAAOL,EAAIc,KAGnCR,EAAAC,EAAAC,cAAA,OAAA,CAAMyB,SAAO,EAACH,SAAU,CAAC,EAAG,EAAG,GAAII,SAAU,CAAC,EAAG,EAAG,GAAIC,YAAU,GAChE7B,EAAAC,EAAAC,cAAA,mBAAA,CAAkB4B,UAAW,KAC7B9B,EAAAC,EAAAC,cAAA,iBAAA,CAAgB6B,OAAO,WAAW3B,KAAM,CAAC,EAAG,GAAI,MAChDJ,EAAAC,EAAAC,cAAA,oBAAA,CACE6B,OAAO,WACPC,OAAQV,EAAWW,aAAaxB,QAChCyB,MAAM,QACNC,UAAW,GACXC,UAAW,KAwBJC,IAAAA,EAjBf,WACE,OACErC,EAAAC,EAAAC,cAAAF,EAAAC,EAAAqC,SAAA,KACEtC,EAAAC,EAAAC,cAACqC,EAAA,EAAD,CAAQC,UAAU,UAChBxC,EAAAC,EAAAC,cAACuC,EAAD,MACAzC,EAAAC,EAAAC,cAACW,EAAD,MACAb,EAAAC,EAAAC,cAACK,EAAD,OAGFP,EAAAC,EAAAC,cAAA,MAAA,CAAKsC,UAAU,WACbxC,EAAAC,EAAAC,cAAA,IAAA,KAAA,oCACAF,EAAAC,EAAAC,cAAA,IAAA,KAAA,8CC/FFwC,EAAcC,SAASC,eAAe,QAC5CC,EAAAA,EAASC,OACP9C,EAAAC,EAAAC,cAACF,EAAAC,EAAM8C,WAAP,KACE/C,EAAAC,EAAAC,cAAC8C,EAAD,OAEFN\",\"sourcesContent\":[\"import React, { useRef } from \\\"react\\\";\\nimport { Canvas, extend, useThree, useFrame } from \\\"react-three-fiber\\\";\\nimport {\\n  CubeTextureLoader,\\n  CubeCamera,\\n  WebGLCubeRenderTarget,\\n  RGBFormat,\\n  LinearMipmapLinearFilter\\n} from \\\"three\\\";\\nimport { OrbitControls } from \\\"three/examples/jsm/controls/OrbitControls\\\";\\nimport \\\"./styles.css\\\";\\n\\nextend({ OrbitControls });\\n\\nconst CameraControls = () => {\\n  // Get a reference to the Three.js Camera, and the canvas html element.\\n  // We need these to setup the OrbitControls class.\\n  // https://threejs.org/docs/#examples/en/controls/OrbitControls\\n\\n  const {\\n    camera,\\n    gl: { domElement }\\n  } = useThree();\\n\\n  // Ref to the controls, so that we can update them on every frame using useFrame\\n  const controls = useRef();\\n  useFrame(() => controls.current.update());\\n  return (\\n    <orbitControls\\n      ref={controls}\\n      args={[camera, domElement]}\\n      autoRotate={false}\\n      enableZoom={false}\\n    />\\n  );\\n};\\n\\n// Loads the skybox texture and applies it to the scene.\\nfunction SkyBox() {\\n  const { scene } = useThree();\\n  const loader = new CubeTextureLoader();\\n  // The CubeTextureLoader load method takes an array of urls representing all 6 sides of the cube.\\n  const texture = loader.load([\\n    \\\"/1.jpg\\\",\\n    \\\"/2.jpg\\\",\\n    \\\"/3.jpg\\\",\\n    \\\"/4.jpg\\\",\\n    \\\"/5.jpg\\\",\\n    \\\"/6.jpg\\\"\\n  ]);\\n\\n  // Set the scene background property to the resulting texture.\\n  scene.background = texture;\\n  return null;\\n}\\n\\n// Geometry\\nfunction Sphere() {\\n  const { scene, gl } = useThree();\\n  // The cubeRenderTarget is used to generate a texture for the reflective sphere.\\n  // It must be updated on each frame in order to track camera movement and other changes.\\n  const cubeRenderTarget = new WebGLCubeRenderTarget(256, {\\n    format: RGBFormat,\\n    generateMipmaps: true,\\n    minFilter: LinearMipmapLinearFilter\\n  });\\n  const cubeCamera = new CubeCamera(1, 1000, cubeRenderTarget);\\n  cubeCamera.position.set(0, 0, 0);\\n  scene.add(cubeCamera);\\n\\n  // Update the cubeCamera with current renderer and scene.\\n  useFrame(() => cubeCamera.update(gl, scene));\\n\\n  return (\\n    <mesh visible position={[0, 0, 0]} rotation={[0, 0, 0]} castShadow>\\n      <directionalLight intensity={0.5} />\\n      <sphereGeometry attach=\\\"geometry\\\" args={[2, 32, 32]} />\\n      <meshBasicMaterial\\n        attach=\\\"material\\\"\\n        envMap={cubeCamera.renderTarget.texture}\\n        color=\\\"white\\\"\\n        roughness={0.1}\\n        metalness={1}\\n      />\\n    </mesh>\\n  );\\n}\\n\\n// Lights\\nfunction App() {\\n  return (\\n    <>\\n      <Canvas className=\\\"canvas\\\">\\n        <CameraControls />\\n        <Sphere />\\n        <SkyBox />\\n      </Canvas>\\n\\n      <div className=\\\"startup\\\">\\n        <p>* Use mouse to rotate the camera</p>\\n        <p>* Use arrows to move camera axis around</p>\\n      </div>\\n    </>\\n  );\\n}\\n\\nexport default App;\\n\",\"import React from \\\"react\\\";\\nimport ReactDOM from \\\"react-dom\\\";\\n\\nimport App from \\\"./App\\\";\\n\\nconst rootElement = document.getElementById(\\\"root\\\");\\nReactDOM.render(\\n  <React.StrictMode>\\n    <App />\\n  </React.StrictMode>,\\n  rootElement\\n);\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{15:function(e,t,a){e.exports=a(27)},20:function(e,t,a){},27:function(e,t,a){\"use strict\";a.r(t);var n=a(0),r=a.n(n),c=a(10),o=a.n(c),l=a(3),u=a(1),i=a(11);a(20);Object(l.b)({OrbitControls:i.a});var m=function(){var e=Object(l.d)(),t=e.camera,a=e.gl.domElement,c=Object(n.useRef)();return Object(l.c)(function(){return c.current.update()}),r.a.createElement(\"orbitControls\",{ref:c,args:[t,a],autoRotate:!1,enableZoom:!1})};function s(){var e=Object(l.d)().scene,t=(new u.CubeTextureLoader).load([\"/1.jpg\",\"/2.jpg\",\"/3.jpg\",\"/4.jpg\",\"/5.jpg\",\"/6.jpg\"]);return e.background=t,null}function p(){var e=Object(l.d)(),t=e.scene,a=e.gl,n=new u.WebGLCubeRenderTarget(256,{format:u.RGBFormat,generateMipmaps:!0,minFilter:u.LinearMipmapLinearFilter}),c=new u.CubeCamera(1,1e3,n);return c.position.set(0,0,0),t.add(c),Object(l.c)(function(){return c.update(a,t)}),r.a.createElement(\"mesh\",{visible:!0,position:[0,0,0],rotation:[0,0,0],castShadow:!0},r.a.createElement(\"directionalLight\",{intensity:.5}),r.a.createElement(\"sphereGeometry\",{attach:\"geometry\",args:[2,32,32]}),r.a.createElement(\"meshBasicMaterial\",{attach:\"material\",envMap:c.renderTarget.texture,color:\"white\",roughness:.1,metalness:1}))}var d=function(){return r.a.createElement(r.a.Fragment,null,r.a.createElement(l.a,{className:\"canvas\"},r.a.createElement(m,null),r.a.createElement(p,null),r.a.createElement(s,null)),r.a.createElement(\"div\",{className:\"startup\"},r.a.createElement(\"p\",null,\"* Use mouse to rotate the camera\"),r.a.createElement(\"p\",null,\"* Use arrows to move camera axis around\")))},b=document.getElementById(\"root\");o.a.render(r.a.createElement(r.a.StrictMode,null,r.a.createElement(d,null)),b)}},[[15,1,2]]]);","extractedComments":[]}